#进程、前后台、服务与例行性任务

!!! abstract 
    进入Linux的世界，便意味着与系统管理直接打交道，无法像windows一样独善其身。系统正在做什么？我们如何给系统安排任务？本章将要带大家走进进程，进而实现Linux更高级的自动化。
        
        1. 进程初探
            * 进程存在意义，基本属性（出现在htop上的条目），进程间通信方式。
            * *Linux进程调度策略简述 <增加内核书目链接以及torvalds/linux目录>
        2. htop的使用（在进程调度方面的应用）
            * 进程间关系演示（进程树），信号传输实现（trap）<杀死几乎所有进程会如何 kill -9 -1>
            * *htop的其他选项（查看文件描述符），从而理解一些特殊文件的存在（如0号stdin，1号stdout，2号stderr）
        3. 将无需交互的程序放入后台
            * ctrl + Z挂起，bg与fg，nohup过继进程
        4. 守护进程与服务
            * 守护进程的工作模式，htop中守护进程的举例。
            * *配置ssh服务演示
        5. 例行性任务设置
            * 定时任务，比如定时upgrade。

```html
    <p>用来激活正文的html代码提示，编写完成即删去</p>
```

##进程
现在设想你有一堆任务在一周之内完成，应该如何下手呢？

一些情况下，我们或许会随机选择一个做，但也许拿出日历，根据轻重缓急排出一个先后来更为合适。计算机同样面临着繁多的事务，CPU的时间也同样需要被安排。

那么在计算机中，操作系统又是如何实现各项工作的安排呢？

!!! tip 
    在最早期的晶体管计算机时代<ref>，没有操作系统，由操作员负责输入输出，意味着处理单元的时间在等待IO的过程中浪费。可见，只有让任务之间衔接得足够快，才能更好地利用处理器性能。当时采用批处理策略集中任务，并由一个处理程序负责加载程序，录入数据，输出结果。这种按录入顺序装载程序并负责IO的处理工作的程序便成为操作系统的雏形。

在以上过程中，操作系统直接面临的就是一个个等待运行的程序，即**进程**。

**进程**是计算机系统三大抽象之一，操作系统秉承“为进程服务”的理念而设计。

![abstract](img/abstract.png)

程序由数据结构和算法构成，程序需要存储资源安身，需要计算资源而一个程序占有资源并运行便成为了进程。程序希望有CPU运行它，希望它需要的数据唾手可得，希望输出的数据可以被正确及时地送达。早期的系统不需要操心进程运行的顺序。然而随着人们对计算机需求越来越高，操作系统除了为进程提供基础服务之外，更需要管理好进程所竞争的资源，甚至要为实时交互提供方案。

!!! tip 
    当时的计算机如果程序等待IO，处理器只能傻等。为了更高效地利用处理器，出现 <abbr title="详见《现代操作系统》P7">**多道程序设计**</abbr>方案，允许充分利用程序IO的时间；为了响应实时要求，出现了**中断(interrupt)**概念<ref>，响应硬件软件中断执行任务的请求；为了实现多人共用，出现了用户概念，而用户又可抽象为用户权限；

##htop使用实例

!!! warning 
    以下命令请勿生产环境中使用。
    
        sudo kill -9 -1
    
    
简单介绍一下kill，在靶机上root执行kill -9 -1

##程序状态转换

###后台任务
除nohup外，bash及其他的shell还可以有内建命令完成脱离
*放置后台之后一直再输出怎么办？（可以留给bash重定向介绍，或者与之前的文件号进行联系）

##服务

##例行性任务

```
##下载链接

*尚未commit

[《现代操作系统》](pdfs/现代操作系统.pdf)

[《linux内核设计与实现》](pdfs/linux内核设计与实现.pdf)