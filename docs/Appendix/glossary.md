# 词汇表

!!! Failure "本文目前尚未完稿，存在诸多未尽章节且未经审阅，不是正式版本。"

**在本次 Linux 101 介绍活动中，你可能会遇到许多新名词。为了便于大致理解概念与作为讲义辅助查阅，我们将本讲义涉及到的基本概念编写于此，正文可在适当位置加以引用。**

*部分词条并非使用专业而严格的方式解释，仅为快速理解而编写，更加严格的定义可参阅各大百科。*

## 操作系统 {#operating-system}

操作系统是管理计算机的软硬件资源，为上层应用程序提供服务的系统程序。当然现在，「操作系统」一词在不同的场合指向的东西是不同的：有时候，「操作系统」指代操作系统内核；有时候，「操作系统」指代从内核到用户界面与（预装的）应用的一个整体；而有的时候，「操作系统」指代内核与「偏向底层」的程序（例如 C 运行时库）的整体。

关于操作系统的更详细的综述，可以查看[第一章](../Ch01/index.md)。[第四章](../Ch04/index.md)中关于进程等的部分，也与操作系统概念联系紧密。

## GNU：GNU is Not UNIX! {#gnu}

!!! tip 

    时间回到上世纪 70-80 年代，一代操作系统巨星 UNIX 在 AT&T 的商业化策略下选择了闭源的策略，不再提供源代码给使用者。这不仅意味着金钱上的制约，更是一种对修改研究软件权力的制约。想想看，如果想对一个文本编辑器添加一个小功能，却由于版权原因被逼写一份自己的编辑器，可以说相当令人绝望。于是，Richard Stallman 带着他的 GNU Emacs 站了出来，号召 hacker 们搭建起自由的软件平台——GNU。

正如标题所见，GNU 的全称使用了一种递归，表达了与 Unix 这种对“自由”的限制决裂的态度。

而进入 GNU/Linux 世界，便意味着将一直与 GNU 软件打交道。先看看一堆字母 g 开头的应用程序：

- gcc: GNU 的 C 和 C++ 编译器
- gdb: GNU 程序调试器
- gzip: gz 格式压缩与解压缩工具
- GNOME: 隶属于 GNU 项目的桌面环境
- gimp: GNU 图像编辑工具

它们的首字母 g 都是 GNU 的缩写（当然有一些例外，例如 grep，一个字符串模式匹配工具）。许多 Linux 上的系统管理命令虽然未必以 g 开头，但都属于自由软件；还有[更多优秀的软件](https://www.gnu.org/software/)，被自由软件爱好者维护、分享……选择 Linux，很大程度上是一种对极客精神与开源文化的认同。

这里有一份[Redhat 公司制作的录音节目 Command Line Heroes](https://www.redhat.com/en/command-line-heroes)，纪念开源世界的历史与文化，对自己英语听力有自信的同学可以选择收听一下。

## 终端 (Terminal) 与控制台 (Console) {#terminal}

还记得在 Unix 诞生之前由通用电器公司主持的 Multics 计划吗？对了，就是可以让用户把一套键盘显示器往墙上一插，直接连接到远端主机的计划。当时键盘和显示器连为一体，称为终端（terminal）。而主机自带的一套键盘与屏幕只能给系统管理员使用，称为控制台 (<abbr title="con- 表强调，-sol 整体，词源同 solid —— 即构成一个整体，整体控制的工具。">console</abbr>)，用来输出启动 debug 信息（现在的 Linux 系统如果因故障而不得不<abbr title="telinit 1">进入单用户修复模式</abbr>，则只有一个终端 `/dev/console` 开启）。

然而随着时代的发展，这种模式逐渐被家庭电脑的分布式主机取代，我们不需要，也没有多套终端了，只有显示器、键盘、鼠标。但是为了向前兼容性，我们需要假装这是一个（甚至多个）终端，所以一般发行版 `/dev` 目录下有 7 个终端 `tty1 ~ tty7`，通过 `ctrl + alt + F1 ~ F7` 切换键盘与显示器与哪个终端相对应。

再后来，随着时代发展，终端需要出现在图形界面上了，然而承载图形界面的也是终端，所以终端里的终端就需要终端模拟器来实现了。由此，出现在图形界面上的终端才叫终端模拟器。

**注意：终端不是 Shell，尽管它们经常被弄混淆。**

参考阅读: [你真的知道什么是终端吗？](https://www.linuxdashen.com/%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%88%E7%AB%AF%E5%90%97%EF%BC%9F)

## 壳层 (Shell) {#shell}

但凡使用 Linux，必然要与之交互。广义上讲，能与用户交互的程序都符合 shell 的定义（比如图形界面可以识别鼠标位置信息，点击操作和键盘快捷键）。然而 Linux 本身以命令行工具为主，而 shell 狭义上就是命令行解释工具，即允许用户在一定程度上「说人话」来调用程序。

Shell 是非常重要的程序。如果发行版中根本没有 shell，用户便无法控制计算机了。

没有图形界面时，shell 一般为控制台 (tty) 的子进程，在图形界面上 shell 建立在虚拟终端 (pty, pseudo tty) 之上。顺带一提，`ssh` 的父进程也是一个 pty。

## 内核 (Kernel) {#kernel}

有壳 (shell) 必有核 (kernel)，只有这里的核才是操作系统本体，真正负责调度程序，管理硬件的部分。而 Linux 发行版本身则是一个套装，意味着一个核用不同的软件包装出来，其中体现着发行版之间不同的理念。

## 中断 (IRQ, Interrupt Request) {#irq}

你正在看书，被电话铃声打断，接完电话，继续读书。这里就很好地阐释了中断的基本原理：电话铃是中断的核心，电话号决定了是谁打来的，你要使用什么语言回应。

从程序的角度来看，中断对应着程序正常执行逻辑被打断，跳转到特定的中断处理程序。上面的电话铃代表是哪个硬件上产生的中断信号，告诉 CPU 应当如何处理。处理完之后自然回到正在运行的程序中（或者如果电话中老妈让你把饭热上，便对应 CPU 进行调度切换更高「优先级」任务的过程）。

在中断机制中，中断号与其处理程序的映射尤为重要，这些映射储存在中断向量表中。

没有中断，计算机仍将停留在批处理年代的早期，只能管理 IO，无法进行调度。

参考阅读：[Linux 内核中断内幕](https://www.ibm.com/developerworks/cn/linux/l-cn-linuxkernelint/index.html)

### 时钟中断 {#clock-irq}

操作系统之所以可以单核多任务（并发），很大程度上是由于时钟中断的存在。时钟电路每隔一段时间会发送时钟中断，在收到这个中断之后，CPU 就会保存当前执行的程序的状态，然后执行操作系统的调度程序，调度程序会（根据调度算法）选择下一个执行的程序。

## 系统调用 (System Call) {#system-call}

如果说进程调度体现了系统进程与资源的管理作用，那么系统调用体现的是系统为进程提供服务的功能。操作系统既然提供了对硬件的抽象，那么必然要让程序去使用这些抽象。于是系统调用可以按照其提供的抽象分为针对进程的，针对文件的，针对内存的，针对用户的调用。除此之外还有网络管理以及调节操作系统自身的调用。我们所熟悉的各种操作：例如读写磁盘文件、程序分配堆内存（例如 `malloc()`）、在终端上输入输出等，都需要经过系统调用。

系统调用运行在操作系统核心，为内核与用户层提供了一种通信的方式，是各用户进程「使用」操作系统的统一接口。如果没有系统调用，用户程序就需要直接操作内核来进行需要的操作，而这对于现代操作系统来说显然是无法接受的。

## POSIX 标准 {#posix}

## 内建命令 {#builtin-command}

```shell
$ whereis ls
$ whereis bg
```

## 文件描述符 {#file-descriptor}

