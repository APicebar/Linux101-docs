# 拓展阅读 {#supplement}

**_以下内容为编者认为有参考价值应当提及的内容。为了不破坏章节主旨的连续性与阅读体验连续性，特置于此。_**

## 类 C 语言的 for 循环 {c-style-for}

```shell
for((assignment;condition;next));do
    command_1;
    command_2;
done;
```

这里的 for 循环与 C 中的相似。我们知道，在 shell 里变量调用需要加 `$`，但是 for 中的 `(())` 中不需要。

!!! example "范例"

    shell 脚本内容：

    ```shell
    #!/bin/bash
    for((i=1;i<=5;i++));do
        echo "这是第 $i 次调用";
    done;
    ```

    输出结果：

    ```text
    这是第1次调用
    这是第2次调用
    这是第3次调用
    这是第4次调用
    这是第5次调用
    ```

与 C 中相似，赋值和下一步执行可以放到代码之前循环语句之中执行，这里要注意一点：如果要在循环体中进行 for 中的 next 操作，记得变量要加 $，不然程序会变成死循环。

## Fork 炸弹 {fork-bomb}

!!! Warning "命令含有危险性"
    以下的命令均包含一定的危险性，请在任何情况下都不要执行，除非你清楚你在做什么。

### 原理 {fork-bomb-theory}

Fork 炸弹有如下的这种形式：

```shell
:(){ :|: & };:
```

这是一个函数定义以及对其的调用语句，可以格式化为：

```shell
:()
{
    :|: &
};
:
```

在 Bash 中，`:`、`.`、`/` 等一些字符也能够被用于函数命名，因此，上面的代码等价于：

```shell
func()
{
    func | func &
};
func
```

fork 炸弹的核心是函数内容：`func | func &`

- 第一个 func 代表递归执行这个函数。
- | 代表要将第一个函数的数据结果通过管道传输给后一个函数。
- & 代表要在后台执行这一条命令，如果其中一个函数被操作系统回收，其调用产生的子函数并不会被回收。

通过这个方式，在运行一次这个函数，会创建两个 func 函数的实例，并不断地反复调用。实例的数量会指数爆炸式地增长，最终耗尽系统的资源。

### 防范方法[^1] {fork-bomb-prevention}

一个有效的方式是通过修改系统配置，限制一个用户能够拥有的进程数量多少。`ulimit -u 30` 可以限制当前用户能够拥有的进程数量为 30。

## 引用来源 {#references .no-underline }

[^1]: [Fork Bomb](https://en.wikipedia.org/wiki/Fork_bomb)